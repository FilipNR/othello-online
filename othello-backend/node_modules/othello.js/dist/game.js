"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Game = void 0;
const definition_1 = require("./definition");
const board_1 = require("./structure/board");
/**
 * Main game class
 */
class Game {
    /**
     * Instantiate game object.
     * @param config configuration of new game
     */
    constructor(config) {
        this._board = null;
        this._state = {
            status: "ready"
        };
        this._config = null;
        this._events = [];
        this._listeners = {
            ready: [], black: [], white: [], finish: []
        };
        this._config = Object.assign(Object.assign({}, config), definition_1.defaultGameConfig);
        this._board = new board_1.OthelloBoardManager(this._config);
        this.emit("ready", [config]);
    }
    /**
     * Current white stone status
     */
    get white() {
        return this._board.getInfo("white");
    }
    /**
     * Current black stone status
     */
    get black() {
        return this._board.getInfo("black");
    }
    /**
     * Current game status
     */
    get state() {
        return this._state;
    }
    set state(value) {
        this._state = value;
    }
    /**
     * Current othello board
     */
    get board() {
        return this._board;
    }
    /**
     * Put a stone.
     * @param config the configuration of this action.
     * @returns the result of this action.
     */
    put(config) {
        const result = this._board["put"](config);
        if (result.winner) {
            this.emit("finish", [result]);
        }
        else {
            this.emit(this._board.nextStone, [this]);
        }
        return result;
    }
    /**
     * Write current board image to console.
     * You shoudn't use this in production.
     * You can use this for the debug purpose only.
     * @param logger a function to log the game state. default console.log
     */
    logBoard(logger = console.log) {
        logger("  ０１２３４５６７");
        logger("  ――――――――");
        for (let y = 0; y < 8; y++) {
            const line = y + "|" + [...Array(8)].map((_, x) => {
                const type = this._board.getCell(x, y).type;
                switch (type) {
                    case "black": return "●";
                    case "white": return "○";
                    case "none": return "　";
                }
            }).join("") + "|";
            console.log(line);
        }
        logger("  ――――――――");
        logger("Next: " + (this._board.nextStone === "black" ? "●" : "○") + this._board.nextStone);
        logger("Turn count: " + this.board.putLog.length);
    }
    /**
     * Add a listener of game event.
     * @param event the event name you'd like to listen to.
     * @param fn the listener you'd like to add.
     */
    addListener(event, fn) {
        this._listeners[event].push(fn);
    }
    /**
     * Remove a listener of game event.
     * @param event the event name that the handle you'd like to remove has been listening to.
     * @param fn the listener you'd like to remove.
     * @returns Result of removal. If it's successful, true, otherwise false.
     */
    removeListener(event, fn) {
        const index = this._listeners[event].findIndex(l => l === fn);
        if (index < 0)
            return false;
        this._listeners[event].splice(index, 1);
        return true;
    }
    /**
     * Emit a game event.
     * You shouldn't use this method.
     * @param event the event you'd like to emit.
     * @param args the event args that will be sent to the handlers.
     */
    emit(event, args) {
        this._listeners[event].forEach(listener => listener(...args));
        this._events.push({ event, args });
    }
}
exports.Game = Game;
